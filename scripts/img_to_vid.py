# Disclaimer: This script was generated by an LLM

import os
import cv2
import numpy as np
# PIL is not strictly necessary for video creation with OpenCV,
# but the original code used it, so we'll keep the import though it's unused in the video part.
# from PIL import Image

def create_video_from_images(image_folder, output_path, duration_ms):
    """
    Reads images from a folder, sorts them, and creates a video file.

    Args:
        image_folder (str): Path to the folder containing images.
        output_path (str): Path to save the output video file (e.g., video.avi, video.mp4).
        duration_ms (int): Duration of each frame in milliseconds.
    """
    # Get a list of image files in the folder
    # Added .png to common image formats
    images = [img for img in os.listdir(image_folder) if img.lower().endswith(('.bmp', '.jpg', '.jpeg', '.png'))]

    # Sort the images by the numerical part of the filename
    # This sorting works well for sequences like image001.jpg, image002.jpg, etc.
    images.sort(key=lambda x: int(''.join(filter(str.isdigit, x))) if any(char.isdigit() for char in x) else 0)

    # Check if there are any images found
    if not images:
        print(f"No images found in folder: {image_folder}. Supported formats: .bmp, .jpg, .jpeg, .png")
        return

    # Remove last, possibly corrupted frame
    if len(images) > 1:
        images = images[:-1]
    # Read the first image to get dimensions
    first_image_path = os.path.join(image_folder, images[0])
    try:
        # Use cv2 to read the image as it's needed for video writing
        first_frame = cv2.imread(first_image_path)
        if first_frame is None:
            print(f"Error: Could not read the first image: {first_image_path}. Check file integrity or permissions.")
            return
        height, width, layers = first_frame.shape
    except Exception as e:
        print(f"Error reading the first image {first_image_path}: {e}")
        return

    # Define the codec and create VideoWriter object
    # FOURCC (Four Character Code) specifies the video codec.
    # Common codecs:
    # 'XVID': Good for .avi files, provides decent compression and quality.
    # 'MP4V': Can be used for .mp4 files.
    # 'MJPG': Creates motion JPEG video, larger file size but widely compatible.
    # 'H264': A modern and efficient codec, but availability can depend on OpenCV build and system libraries.
    # We'll use 'XVID' as a common and reliable option for .avi.
    # If you want MP4, 'MP4V' is an option, or 'avc1' which often requires a specific backend.
    # Using '*'' expands the string "XVID" into four separate characters.
    fourcc = cv2.VideoWriter_fourcc(*'XVID') # Codec for .avi output

    # Calculate frames per second (FPS)
    if duration_ms <= 0:
        print("Error: Frame duration must be positive.")
        return
    fps = 1000.0 / duration_ms

    # Create the VideoWriter object
    try:
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
    except Exception as e:
        print(f"Error initializing VideoWriter: {e}")
        print("Please ensure you have the necessary codecs installed and your output path is valid.")
        return

    # Write frames to the video file
    print(f"Writing {len(images)} frames at {fps:.2f} FPS...")
    for i, image_name in enumerate(images):
        image_path = os.path.join(image_folder, image_name)
        try:
            frame = cv2.imread(image_path)
            if frame is None:
                print(f"Warning: Could not read image {image_name}. Skipping frame {i+1}.")
                continue

            # Optional: Resize frame if dimensions are inconsistent (unlikely with sorted sequences)
            # if frame.shape[:2] != (height, width):
            #    frame = cv2.resize(frame, (width, height))

            out.write(frame)

        except Exception as e:
            print(f"Error processing image {image_name}: {e}. Skipping.")
            continue

        # Optional: Print progress
        # if (i + 1) % 100 == 0 or (i + 1) == len(images):
        #    print(f"Processed {i + 1}/{len(images)} frames")


    # Release the VideoWriter and destroy any OpenCV windows
    out.release()
    # cv2.destroyAllWindows() # Not usually needed for headless processing

    print(f"Video creation complete. Saved to: {output_path}")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Create a video from images in a folder.")
    parser.add_argument("image_folder", type=str, help="Path to the folder containing images.")
    # Changed default output extension and help text to reflect video output (.avi)
    parser.add_argument("--output", type=str, default="output.avi",
                        help="Path to save the output video. Specify file extension like .avi or .mp4.")
    # Duration is in milliseconds per frame
    parser.add_argument("--duration", type=int, default=100,
                        help="Duration of each frame in milliseconds. 1000ms = 1 second. (e.g., 100ms = 10 FPS)")

    args = parser.parse_args()

    # Check if the specified image folder exists
    if not os.path.isdir(args.image_folder):
        print(f"Error: Image folder not found at '{args.image_folder}'")
    else:
        print(f"Attempting to create video: '{args.output}' from images in '{args.image_folder}' with {args.duration}ms duration per frame.")
        # Calculate and show approximate FPS based on duration
        if args.duration > 0:
            print(f"(Approximate FPS: {1000.0 / args.duration:.2f})")
        else:
             print("(Duration must be positive for FPS calculation)")


        # Call the video creation function
        create_video_from_images(args.image_folder, args.output, args.duration)